<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <title>CMDNote</title>
  <link href="https://fonts.googleapis.com/css2?family=PT+Mono&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20,200,0,0" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
    }
    html, body {
      height: 100dvh;
      overscroll-behavior: none;
      touch-action: manipulation;
      -webkit-text-size-adjust: 100%;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: 'PT Mono', monospace;
      font-size: 16px;
      background-color: #ffffff;
      color: #222;
      display: flex;
      flex-direction: column;
      /* Ensure app fills viewport; avoid centering which can affect scrolling */
    }

    .app-container {
      width: 100vw;
      max-width: 100vw;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      margin: 0;
      position: relative;
    }

    @media (min-width: 641px) {
      .app-container {
        width: 100%;
        max-width: 600px;
        margin: 0 auto;
      }
    }
    
    #note-container {
      flex: 1;
      overflow-y: auto;
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0px;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      scrollbar-gutter: stable both-edges;
    
      padding-bottom: 6rem; /* reserve space for controls */
    }

    @media (min-width: 641px) {
      #note-container {
        padding: 1rem;
      }
    }
    #note-container .spacer {
      flex: 1 0 auto;
    }
    
    /* Hide scrollbar but keep scrolling */
    #note-container::-webkit-scrollbar {
      display: none;
    }
    #note-container {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    
    .note-block {
      position: relative;
      padding: var(--gutter) var(--gutter) 3rem var(--gutter);
      background: #ffffff;
      white-space: pre-wrap;
      line-height: 1.6;
      transition: all 300ms ease-out;
      outline: none;
    }
    
    .note-actions {
      position: absolute;
      bottom: 1rem;
      right: 1rem;
      display: flex;
      gap: 0.5rem;
      opacity: 0;
      transition: opacity 300ms ease-in-out;
    }
    
    .note-block:hover .note-actions {
      opacity: 1;
    }

    .note-block:focus-within,
    .note-block[contenteditable="true"]:focus {
      background: #F5F5F5;
    }
    
    .action-btn {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: none;
      background-color: transparent;
      color: #222;
      font-size: 18px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 300ms ease-in-out;
      font-family: 'Material Symbols Outlined';
      font-weight: normal;
      font-style: normal;
      font-variation-settings:
        'FILL' 0,
        'wght' 200,
        'GRAD' 0,
        'opsz' 20;
    }
    
    .action-btn:hover {
      background-color: #333;
      color: white;
    }
    
    .copy-btn {
      position: absolute;
      top: 0.5em;
      right: 0.75em;
      font-size: 0.85em;
      background: none;
      border: none;
      color: #aaa;
      cursor: pointer;
      display: none;
    }
    
    .note-block:hover .copy-btn {
      display: none;
    }
    
    .note-block h1, .note-block h2, .note-block h3 {
      margin: 0.5em 0;
      font-weight: bold;
    }
    .note-block h1 { font-size: 1.2em; }
    .note-block h2 { font-size: 1.1em; }
    .note-block h3 { font-size: 1em; }
    .note-block strong { font-weight: bold; }
    .note-block em { font-style: italic; }
    .note-block code {
      background: #f5f5f5;
      padding: 0.2em 0.4em;
    }
    .note-block pre {
      background: #f5f5f5;
      padding: 1em;
      overflow-x: auto;
    }
    .note-block ul, .note-block ol {
      margin: 0.5em 0;
      padding-left: 2em;
    }
    .wiki-link {
      color: #0066cc;
      text-decoration: underline;
      cursor: pointer;
    }
    .tag {
      color: #666;
      font-weight: bold;
    }
    
    #cmd-line {
  margin: 0 0.75rem 0.75rem 0.75rem;
  padding: 0.75rem 0.75rem calc(0.75rem + env(safe-area-inset-bottom)) 0.75rem;
  background: #ffffff;
  position: sticky;
  bottom: 0;
  min-height: 100px;
  display: grid;
  grid-template-columns: 1fr auto;
  grid-template-rows: auto auto;
  grid-template-areas:
    'input input'
    'note  btn';
  row-gap: 12px; /* space between textarea and notif row */
  column-gap: 0;
  align-items: end;
}
@media (min-width: 641px) {
  #cmd-line {
    margin: 0 1rem 1rem 1rem;
    padding: 1rem 1rem calc(1rem + env(safe-area-inset-bottom)) 1rem;
    min-height: 120px;
    row-gap: 12px;
    column-gap: 0;
  }
}

    @media (min-width: 641px) {
      #cmd-line {
        margin: 0 1rem 1rem 1rem;
        padding: 1rem;
        min-height: 120px;
        padding-bottom: calc(1rem + env(safe-area-inset-bottom));
      }
    }
    
    #cmd-input {
  padding-inline-start: 4px; /* align with note content gutter */
  padding-block: 0.5rem;
  grid-area: input;
      width: 100%;
      min-height: 60px;
      max-height: clamp(80px, 35vh, 200px);
      font-size: 16px;
      font-family: inherit;
      border: none;
      outline: none;
      background: none;
      resize: none;
      line-height: 1.6;
      overflow-y: auto;
    
      /* reserve space for '>' button */
      /* reserve space for notification */
    
      /* padding-block-end: 48px; /* reserve vertical space under button */
    

}

    @media (min-width: 641px) {
      #cmd-input {
        min-height: 80px;
        max-height: clamp(96px, 28vh, 260px);
      }
    }
    
    #cmd-input::placeholder {
      color: #C1C1C1;
    }
    
    #exec-btn {
  grid-area: btn;
  width: 32px;
  height: 32px;
  border: 1px solid #333;
  background: #ffffff;
  color: #333;
  font-size: 16px;
  font-family: 'PT Mono', monospace;
  font-weight: normal;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 200ms ease;
  -webkit-tap-highlight-color: transparent;

  margin-inline-start: var(--gutter);
}
    
    #exec-btn:hover {
      background: #333;
      color: #ffffff;
    }
    
    #exec-btn:active {
      transform: scale(0.95);
    }
    
    #exec-btn:focus {
      outline: none;
    }
    
    #note-notification {
  grid-area: note;
  font-size: 16px;
  font-family: 'PT Mono', monospace;
  color: #333;
  cursor: pointer;
  opacity: 0;
  transition: opacity 200ms ease;
  display: flex;
  align-items: center;
  min-height: 32px; /* aligns with button height */

  padding-inline-start: var(--gutter);
}
#note-notification .view-text { text-decoration: underline; }
    
    #note-notification .view-text {
      text-decoration: underline;
    }
  :root{--gutter:1.5rem;}
</style>
</head>
<body>
  <div class="app-container">
    <div id="note-container"><div id="note-spacer" class="spacer"></div></div>
    <div id="cmd-line">
      <textarea id="cmd-input" placeholder="Start typing or use /commands..." autocomplete="off" autofocus></textarea>
      <button id="exec-btn">&gt;</button>
      <div id="note-notification">[+] Note added. <span class="view-text">View</span></div>
    </div>
  </div>
  <script>
    const cmdInput = document.getElementById('cmd-input');
    const noteContainer = document.getElementById('note-container');
    const execBtn = document.getElementById('exec-btn');
    const noteNotification = document.getElementById('note-notification');
    
    // Execute button functionality
    execBtn.addEventListener('click', function() {
      const input = cmdInput.value;
      processCommand(input);
      cmdInput.value = '';
      cmdInput.classList.remove('command-mode');
      autoResize(cmdInput);
    });
    
    // Fix iOS button state sticking
    execBtn.addEventListener('pointerup', () => execBtn.blur());
    execBtn.addEventListener('touchend', () => execBtn.blur(), { passive: true });
    execBtn.addEventListener('mouseup', () => execBtn.blur());
    
    // Note notification functionality
    noteNotification.addEventListener('click', function() {
      scrollToBottom(noteContainer);
      hideNotification();
    });
    
    function showNotification() {
      noteNotification.style.opacity = '1';
      // Auto-hide after 4 seconds
      setTimeout(() => {
        hideNotification();
      }, 4000);
    }
    
    function hideNotification() {
      noteNotification.style.opacity = '0';
    }
    
    // Generic message function for consistent messaging
    function showMessage(text, duration = 4000) {
      noteNotification.innerHTML = text;
      noteNotification.style.opacity = '1';
      // Auto-hide after specified duration
      setTimeout(() => {
        hideNotification();
      }, duration);
    }
    
    // Storage functions
    function saveNotes(notes) {
      try {
        window.savedNotes = notes;
      } catch (e) {
        console.warn('Could not save notes');
      }
    }
    
    function loadNotes() {
      try {
        return window.savedNotes || [];
      } catch (e) {
        return [];
      }
    }
    
    let notes = loadNotes();
    let noteIdCounter = notes.length;
    
    // Scrolling helpers
    function isUserNearBottom(container, threshold = 24) {
      const distanceFromBottom = container.scrollHeight - container.scrollTop - container.clientHeight;
      return distanceFromBottom <= threshold;
    }
    
    function scrollToBottom(container) {
      container.scrollTop = container.scrollHeight;
    }

    function scrollToTop(container) {
      container.scrollTop = 0;
    }

    // Extract only user content from a note block (exclude action buttons)
    function getNoteTextFromBlock(block) {
      const clone = block.cloneNode(true);
      const actions = clone.querySelectorAll('.note-actions');
      actions.forEach(function(el) { el.remove(); });
      return clone.innerText;
    }
    
    // Simple markdown parser
    function parseMarkdown(text) {
      return text
        // Headers
        .replace(/^### (.*$)/gm, '<h3>$1</h3>')
        .replace(/^## (.*$)/gm, '<h2>$1</h2>')
        .replace(/^# (.*$)/gm, '<h1>$1</h1>')
        // Bold and italic
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        // Code
        .replace(/`([^`]+)`/g, '<code>$1</code>')
        // Wiki links
        .replace(/\[\[(.*?)\]\]/g, '<span class="wiki-link" data-link="$1">$1</span>')
        // Tags
        .replace(/(^|\s)(#\w+)/g, '$1<span class="tag">$2</span>')
        // Lists (basic)
        .replace(/^\* (.+)$/gm, '<li>$1</li>')
        .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
        .replace(/^\d+\. (.+)$/gm, '<li>$1</li>');
    }
    
    // Add action buttons (copy and delete)
    function addActionButtons(block, note) {
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'note-actions';
      actionsDiv.setAttribute('contenteditable', 'false');
      
      // Copy button
      const copyBtn = document.createElement('button');
      copyBtn.className = 'action-btn';
      copyBtn.textContent = 'content_copy';
      copyBtn.onclick = () => {
        // Get only the note content, excluding the buttons
        const contentClone = block.cloneNode(true);
        const actionsToRemove = contentClone.querySelector('.note-actions');
        if (actionsToRemove) {
          actionsToRemove.remove();
        }
        const text = contentClone.innerText;
        
        navigator.clipboard.writeText(text).then(() => {
          copyBtn.textContent = 'check';
          setTimeout(() => {
            copyBtn.textContent = 'content_copy';
          }, 1000);
        });
      };
      
      // Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'action-btn';
      deleteBtn.textContent = 'delete';
      deleteBtn.onclick = () => {
        // Remove from notes array
        const index = notes.findIndex(n => n.id === note.id);
        if (index > -1) {
          notes.splice(index, 1);
          saveNotes(notes);
        }
        // Remove from DOM
        block.remove();
      };
      
      actionsDiv.appendChild(copyBtn);
      actionsDiv.appendChild(deleteBtn);
      block.appendChild(actionsDiv);
    }
    
    function createNoteElement(note) {
      const block = document.createElement('div');
      block.className = 'note-block';
      block.setAttribute('contenteditable', 'true');
      block.dataset.id = String(note.id);
      
      const parsedContent = parseMarkdown(note.content);
      block.innerHTML = parsedContent;
      
      // Add action buttons
      addActionButtons(block, note);
      
      // Editing behavior
      let isComposing = false;
      block.addEventListener('compositionstart', function() { isComposing = true; });
      block.addEventListener('compositionend', function() { isComposing = false; });

      block.addEventListener('input', function() {
        if (isComposing) return;
        const id = note.id;
        const idx = notes.findIndex(n => n.id === id);
        if (idx > -1) {
          // Save raw text (exclude action buttons) while typing to avoid caret jumps
          notes[idx].content = getNoteTextFromBlock(block);
          saveNotes(notes);
        }
      });

      block.addEventListener('blur', function() {
        // On blur, re-parse markdown and restore action buttons
        const id = note.id;
        const idx = notes.findIndex(n => n.id === id);
        if (idx > -1) {
          const currentText = getNoteTextFromBlock(block);
          notes[idx].content = currentText;
          saveNotes(notes);
          // Re-render parsed content
          block.innerHTML = parseMarkdown(currentText);
          addActionButtons(block, notes[idx]);
        }
      });

      return block;
    }
    
    let stickToBottom = true;
    let lastManualScrollAt = 0;

    noteContainer.addEventListener('scroll', function() {
      // Update stickiness based on user position
      stickToBottom = isUserNearBottom(noteContainer);
      lastManualScrollAt = Date.now();
    });

    function addNote(content) {
      // Only auto-stick if user is near bottom and hasn't scrolled manually very recently
      const recentlyScrolledManually = Date.now() - lastManualScrollAt < 800;
      const shouldStickToBottom = stickToBottom && !recentlyScrolledManually;
      const note = {
        id: ++noteIdCounter,
        content: content,
        created: new Date().toISOString()
      };
      notes.push(note);
      saveNotes(notes);
      
      const noteEl = createNoteElement(note);
      noteContainer.appendChild(noteEl);
      
      // Auto-scroll only if user was near bottom when the note was added
      if (shouldStickToBottom) {
        scrollToBottom(noteContainer);
      } else {
        // Show notification if not auto-scrolling
        showMessage('[+] Note added. <span class="view-text">View</span>');
      }
    }
    
    function showSearchResults(query) {
      const results = notes.filter(note => 
        note.content.toLowerCase().includes(query.toLowerCase())
      );
      
      let elements = [];
      
      if (results.length === 0) {
        showMessage(`[!] No notes found for "${query}"`);
        return;
      } else {
        elements = results.map(note => {
          const block = document.createElement('div');
          block.className = 'note-block';
          
          const highlightedContent = note.content.replace(
            new RegExp(`(${query})`, 'gi'), 
            '<strong>$1</strong>'
          );
          block.innerHTML = parseMarkdown(highlightedContent);
          addActionButtons(block, note);
          return block;
        });
      }
      
      showResultsBottomToTop(elements);
      notesBackup = []; // Clear backup after successful search
      isInSearchMode = false;
      scrollToBottom(noteContainer);
    }
    
    // Export function
    function exportNotes() {
      if (notes.length === 0) {
        showMessage('[!] No notes to export');
        return;
      }
      
      // Create markdown content
      let markdown = '# CMDNote Export\n\n';
      markdown += `Exported on ${new Date().toLocaleString()}\n`;
      markdown += `Total notes: ${notes.length}\n\n`;
      markdown += '---\n\n';
      
      notes.forEach((note, index) => {
        const date = new Date(note.created).toLocaleString();
        markdown += `## Note ${index + 1}\n`;
        markdown += `*Created: ${date}*\n\n`;
        markdown += note.content + '\n\n';
        markdown += '---\n\n';
      });
      
      // Create and download file
      const blob = new Blob([markdown], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `cmdnote-export-${new Date().toISOString().split('T')[0]}.md`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      // Show success message with animation
      showMessage(`[+] Exported ${notes.length} notes to markdown file`, 3000);
    }
    
    // Command processing
    function processCommand(input) {
      const trimmed = input.trim();
      
      if (trimmed.startsWith('/search ')) {
        const query = trimmed.replace('/search ', '').trim();
        if (query) {
          showSearchResults(query);
        }
      } else if (trimmed === '/clear') {
        clearSearchResults();
      } else if (trimmed === '/export') {
        exportNotes();
      } else if (trimmed) {
        addNote(trimmed);
      }
    }
    
    function clearSearchResults() {
      // Clear current view
      const currentBlocks = Array.from(noteContainer.children).filter(function(el) { return !el.classList.contains('spacer'); });
      
      if (currentBlocks.length > 0) {
        // Delete current results bottom-to-top
        let index = currentBlocks.length - 1;
        
        const deleteNext = () => {
          if (index < 0) {
            // After clearing, show all original notes
            showAllOriginalNotes();
            return;
          }
          
          const block = currentBlocks[index];
          block.style.opacity = '0';
          block.style.transform = 'translateY(-20px)';
          
          setTimeout(() => {
            if (block.parentNode) {
              block.remove();
            }
            index--;
            deleteNext();
          }, 80);
        };
        
        deleteNext();
      } else {
        showAllOriginalNotes();
      }
    }
    
    function showAllOriginalNotes() {
      if (notes.length === 0) return;
      
      // Create actual DOM elements instead of HTML strings
      const elements = notes.map(note => {
        const block = document.createElement('div');
        block.className = 'note-block';
        block.setAttribute('contenteditable', 'true');
        block.dataset.id = String(note.id);
        block.innerHTML = parseMarkdown(note.content);
        addActionButtons(block, note);

        // Attach editing events
        let isComposing = false;
        block.addEventListener('compositionstart', function() { isComposing = true; });
        block.addEventListener('compositionend', function() { isComposing = false; });
        block.addEventListener('input', function() {
          if (isComposing) return;
          const id = note.id;
          const idx = notes.findIndex(n => n.id === id);
          if (idx > -1) {
            notes[idx].content = getNoteTextFromBlock(block);
            saveNotes(notes);
          }
        });
        block.addEventListener('blur', function() {
          const id = note.id;
          const idx = notes.findIndex(n => n.id === id);
          if (idx > -1) {
            const currentText = getNoteTextFromBlock(block);
            notes[idx].content = currentText;
            saveNotes(notes);
            block.innerHTML = parseMarkdown(currentText);
            addActionButtons(block, notes[idx]);
          }
        });
        return block;
      });
      
      showResultsBottomToTop(elements);
      scrollToBottom(noteContainer);
    }
    
    let isAnimating = false;
    let notesBackup = []; // Store notes before deletion
    let isInSearchMode = false;
    
    // Terminal-style animation functions
    function deleteNotesBottomToTop() {
      return new Promise((resolve) => {
        const noteBlocks = Array.from(noteContainer.children).filter(function(el) { return !el.classList.contains('spacer'); });
        if (noteBlocks.length === 0) {
          resolve();
          return;
        }
        
        // Backup the current notes HTML before deleting
        notesBackup = noteBlocks.map(block => ({
          html: block.outerHTML,
          note: notes.find(n => block.innerHTML.includes(n.content.substring(0, 50)))
        }));
        
        // Delete from bottom to top
        let index = noteBlocks.length - 1;
        
        const deleteNext = () => {
          if (index < 0) {
            resolve();
            return;
          }
          
          const block = noteBlocks[index];
          block.style.opacity = '0';
          block.style.transform = 'translateY(-20px)';
          
          setTimeout(() => {
            if (block.parentNode) {
              block.remove();
            }
            index--;
            deleteNext();
          }, 80);
        };
        
        deleteNext();
      });
    }
    
    function restoreNotesBottomToTop() {
      return new Promise((resolve) => {
        if (notesBackup.length === 0) {
          resolve();
          return;
        }
        
        // Restore notes from backup
        notesBackup.forEach((backup, index) => {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = backup.html;
          const block = tempDiv.firstChild;
          
          block.style.opacity = '0';
          block.style.transform = 'translateY(20px)';
          noteContainer.appendChild(block);
          
          setTimeout(() => {
            block.style.opacity = '1';
            block.style.transform = 'translateY(0)';
            
            if (index === notesBackup.length - 1) {
              resolve();
            }
          }, index * 80);
        });
      });
    }
    
    function showResultsBottomToTop(elements) {
      // Add blocks with initial hidden state
      elements.forEach(element => {
        element.style.opacity = '0';
        element.style.transform = 'translateY(20px)';
        noteContainer.appendChild(element);
      });
      
      // Animate them in from bottom to top
      let index = 0;
      const showNext = () => {
        if (index >= elements.length) {
          return;
        }
        
        const block = elements[index];
        setTimeout(() => {
          block.style.opacity = '1';
          block.style.transform = 'translateY(0)';
          index++;
          showNext();
        }, 80);
      };
      
      showNext();
    }
    
    // Simple command highlighting
    function highlightCommand(input) {
      const value = input.value.trim();
      const commands = ['/search', '/clear', '/export'];
      
      // Check if input starts with a command
      const isCommand = commands.some(cmd => value.startsWith(cmd));
      
      if (isCommand) {
        input.classList.add('command-mode');
      } else {
        input.classList.remove('command-mode');
      }
    }
    
    // Auto-resize textarea with proper CSS synchronization
    function autoResize(textarea) {
      // Read computed min/max from CSS so JS never fights the browser
      textarea.style.height = 'auto';
      const cs = getComputedStyle(textarea);
      const parsePx = v => (typeof v === 'string' && v.endsWith('px')) ? parseFloat(v) : parseFloat(v || '0');
      const minH = Math.max(0, parsePx(cs.minHeight));
      // maxHeight can be 'none' if not set; guard for that
      const maxH = (cs.maxHeight && cs.maxHeight !== 'none') ? parsePx(cs.maxHeight) : Infinity;
      const target = Math.min(maxH, Math.max(minH, textarea.scrollHeight));
      textarea.style.height = target + 'px';
      // Highlight commands
      highlightCommand(textarea);
    }
    
    // Event listeners
    cmdInput.addEventListener('input', function(e) {
      const value = e.target.value;
      
      // Trigger deletion animation when user types space after /search
      if (value === '/search ' && !isAnimating && !isInSearchMode) {
        isAnimating = true;
        isInSearchMode = true;
        deleteNotesBottomToTop().then(() => {
          isAnimating = false;
        });
      }
      
      // Restore notes if user abandons the search command
      if (isInSearchMode && !value.startsWith('/search ') && !isAnimating) {
        isAnimating = true;
        restoreNotesBottomToTop().then(() => {
          isAnimating = false;
          isInSearchMode = false;
        });
      }
      
      autoResize(e.target);
    });
    
    cmdInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        const input = cmdInput.value;
        processCommand(input);
        cmdInput.value = '';
        cmdInput.classList.remove('command-mode');
        autoResize(cmdInput);
      }
    });
    
    // Wiki link click handler
    noteContainer.addEventListener('click', function(e) {
      if (e.target.classList.contains('wiki-link')) {
        const linkText = e.target.dataset.link;
        showSearchResults(linkText);
      }
    });
    
    // Auto-save when page unloads
    window.addEventListener('beforeunload', function() {
      saveNotes(notes);
    });
    
    // Load existing notes on startup
    if (notes.length > 0) {
      notes.forEach(note => {
        const noteEl = createNoteElement(note);
        noteContainer.appendChild(noteEl);
      });
      // Start at bottom initially
      scrollToBottom(noteContainer);
    }

    // Prevent pinch zoom on iOS legacy
    document.addEventListener('gesturestart', e => e.preventDefault(), { passive: false });

    // Removed floating scroll-to-top button
  </script>
</body>
</html>
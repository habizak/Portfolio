<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <title>CMDNote</title>
  <link href="https://fonts.googleapis.com/css2?family=PT+Mono&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20,200,0,0" rel="stylesheet">
  <style>
    :root { --gutter: 1.5rem; }
    * { box-sizing: border-box; }
    html, body { height: 100dvh; overscroll-behavior: none; touch-action: manipulation; -webkit-text-size-adjust: 100%; }
    body { margin: 0; padding: 0; font-family: 'PT Mono', monospace; font-size: 16px; background: #ffffff; color: #222; display: flex; flex-direction: column; }
    .app-container { width: 100vw; max-width: 100vw; height: 100dvh; display: flex; flex-direction: column; margin: 0; position: relative; }
    @media (min-width: 641px) { .app-container { width: 100%; max-width: 600px; margin: 0 auto; } }
    #note-container { flex: 1; overflow-y: auto; padding: 0.75rem; display: flex; flex-direction: column; gap: 0; -webkit-overflow-scrolling: touch; overscroll-behavior: contain; scrollbar-gutter: stable both-edges; padding-bottom: 6rem; }
    @media (min-width: 641px) { #note-container { padding: 1rem; } }
    #note-container .spacer { flex: 1 0 auto; }
    #note-container::-webkit-scrollbar { display: none; }
    #note-container { -ms-overflow-style: none; scrollbar-width: none; }
    
    .note-block { 
      position: relative; 
      padding: var(--gutter) var(--gutter) 3rem var(--gutter); 
      background: #ffffff; 
      white-space: pre-line; 
      line-height: 1.6; 
      transition: background 300ms ease; 
      outline: none;
      contain: content;
      will-change: transform, opacity;
    }
    @media (prefers-reduced-motion: reduce) { 
      .note-block { transition: none; } 
      .note-actions { transition: none; }
    }
    
    .note-actions { position: absolute; bottom: 1rem; right: 1rem; display: flex; gap: 0.5rem; opacity: 0; transition: opacity 300ms ease; }
    .note-block:hover .note-actions { opacity: 1; }
    .note-block:focus { background: #F5F5F5; }
    .action-btn { width: 28px; height: 28px; border-radius: 50%; border: none; background: transparent; color: #222; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 300ms ease; font-family: 'Material Symbols Outlined'; font-weight: normal; font-style: normal; font-variation-settings: 'FILL' 0, 'wght' 200, 'GRAD' 0, 'opsz' 20; }
    .action-btn:hover { background: #333; color: white; }
    .note-block h1, .note-block h2, .note-block h3 { margin: 0.5em 0; font-weight: bold; }
    .note-block h1 { font-size: 1.2em; } .note-block h2 { font-size: 1.1em; } .note-block h3 { font-size: 1em; }
    .note-block strong { font-weight: bold; } .note-block em { font-style: italic; }
    .note-block code { background: #f5f5f5; padding: 0.2em 0.4em; }
    .note-block pre { background: #f5f5f5; padding: 1em; overflow-x: auto; }
    .note-block ul, .note-block ol { margin: 0.5em 0; padding-left: 2em; }
    .wiki-link { color: #0066cc; text-decoration: underline; cursor: pointer; }
    .tag { color: #666; font-weight: bold; }
    #cmd-line { margin: 0 0.75rem 0.75rem 0.75rem; padding: 0.75rem 0.75rem calc(0.75rem + env(safe-area-inset-bottom)) 0.75rem; background: #ffffff; position: sticky; bottom: 0; min-height: 100px; display: grid; grid-template-columns: 1fr auto; grid-template-rows: auto auto; grid-template-areas: 'input input' 'note btn'; row-gap: 12px; column-gap: 0; align-items: end; }
    @media (min-width: 641px) { #cmd-line { margin: 0 1rem 1rem 1rem; padding: 1rem 1rem calc(1rem + env(safe-area-inset-bottom)) 1rem; min-height: 120px; } }
    #cmd-input { grid-area: input; padding-inline-start: 4px; padding-block: 0.5rem; width: 100%; min-height: 60px; max-height: clamp(80px, 35vh, 200px); font-size: 16px; font-family: inherit; border: none; outline: none; background: none; resize: none; line-height: 1.6; overflow-y: auto; }
    @media (min-width: 641px) { #cmd-input { min-height: 80px; max-height: clamp(96px, 28vh, 260px); } }
    #cmd-input::placeholder { color: #C1C1C1; }
    #exec-btn { grid-area: btn; width: 32px; height: 32px; border: 1px solid #333; background: #ffffff; color: #333; font-size: 16px; font-family: 'PT Mono', monospace; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 200ms ease; -webkit-tap-highlight-color: transparent; margin-inline-start: var(--gutter); }
    #exec-btn:hover { background: #333; color: #ffffff; }
    #exec-btn:active { transform: scale(0.95); }
    #exec-btn:focus { outline: none; }
    #note-notification { grid-area: note; font-size: 16px; font-family: 'PT Mono', monospace; color: #333; cursor: pointer; opacity: 0; transition: opacity 200ms ease; display: flex; align-items: center; min-height: 32px; padding-inline-start: 4px; }
    #note-notification .view-text { text-decoration: underline; }
  </style>
</head>
<body>
  <div class="app-container">
    <div id="note-container">
      <div class="spacer"></div>
    </div>
    <div id="cmd-line">
      <textarea id="cmd-input" placeholder="Start typing or use /s, /exp, /cls, /?" autocomplete="off" autofocus></textarea>
      <button id="exec-btn">&gt;</button>
      <div id="note-notification">[+] Note added. <span class="view-text">View</span></div>
    </div>
  </div>
  
  <script>
    let notes = [], searchResults = null;
    const $ = id => document.getElementById(id);
    const container = $('note-container'), input = $('cmd-input'), notification = $('note-notification');
    
    // Markdown cache for massive performance boost
    const mdCache = new Map();
    const mdRegex = [
      [/^### (.*)$/gm, '<h3>$1</h3>'],
      [/^## (.*)$/gm, '<h2>$1</h2>'],
      [/^# (.*)$/gm, '<h1>$1</h1>'],
      [/\*\*(.*?)\*\*/g, '<strong>$1</strong>'],
      [/\*(.*?)\*/g, '<em>$1</em>'],
      [/`([^`]+)`/g, '<code>$1</code>'],
      [/\[\[(.*?)\]\]/g, '<span class="wiki-link" data-link="$1">$1</span>'],
      [/(^|\s)(#\w+)/g, '$1<span class="tag">$2</span>']
    ];
    
    const parseMarkdownCached = text => {
      if (mdCache.has(text)) return mdCache.get(text);
      let html = text;
      for (let [regex, replacement] of mdRegex) {
        html = html.replace(regex, replacement);
      }
      mdCache.set(text, html);
      return html;
    };
    
    // Debounced localStorage persistence
    let saveTimeout;
    const save = () => {
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        try {
          localStorage.setItem('cmdnotes', JSON.stringify(notes));
        } catch (e) {
          console.warn('Could not save notes:', e);
        }
      }, 300);
    };
    
    const load = () => {
      try {
        return JSON.parse(localStorage.getItem('cmdnotes')) || [];
      } catch (e) {
        console.warn('Could not load notes:', e);
        return [];
      }
    };
    
    // Utils
    const show = (text, ms = 4000) => {
      notification.innerHTML = text;
      notification.style.opacity = '1';
      setTimeout(() => notification.style.opacity = '0', ms);
    };
    
    const scroll = () => requestAnimationFrame(() => container.scrollTop = container.scrollHeight);
    
    // Check if user is at the bottom of the scroll container
    const isAtBottom = () => {
      const threshold = 50; // pixels from bottom
      return (container.scrollHeight - container.scrollTop - container.clientHeight) <= threshold;
    };
    
    // Zero-layout auto-resize
    let cachedStyles = null;
    const autoResize = t => {
      if (!cachedStyles) cachedStyles = getComputedStyle(t);
      const currentHeight = t.style.height;
      t.style.height = 'auto';
      const minH = parseFloat(cachedStyles.minHeight) || 0;
      const maxH = cachedStyles.maxHeight !== 'none' ? parseFloat(cachedStyles.maxHeight) : 999;
      const targetHeight = Math.min(maxH, Math.max(minH, t.scrollHeight)) + 'px';
      if (targetHeight !== currentHeight) {
        t.style.height = targetHeight;
      }
    };
    
    const getText = el => {
      const clone = el.cloneNode(true);
      clone.querySelectorAll('.note-actions').forEach(a => a.remove());
      let html = clone.innerHTML;
      html = html.replace(/<br\s*\/?>(?=\n|$)/gi, '\n')
                 .replace(/<\/div><div[^>]*>/gi, '\n')
                 .replace(/<div[^>]*>/gi, '\n')
                 .replace(/<\/div>/gi, '');
      clone.innerHTML = html;
      return (clone.textContent || '').trim();
    };
    
    // Create note with inline actions (no individual event listeners)
    const createNote = note => {
      const block = document.createElement('div');
      block.className = 'note-block';
      block.contentEditable = true;
      block.dataset.id = note.id;
      block.innerHTML = parseMarkdownCached(note.content) + `
        <div class="note-actions">
          <button class="action-btn" data-action="copy">content_copy</button>
          <button class="action-btn" data-action="delete">delete</button>
        </div>`;
      
      // Single input handler with proper debouncing
      let inputTimeout;
      block.oninput = () => {
        clearTimeout(inputTimeout);
        inputTimeout = setTimeout(() => {
          const prev = note.content;
          note.content = getText(block);
          mdCache.delete(prev); // Invalidate cache for previous content
          save();
        }, 300);
      };
      
      block.onblur = () => {
        const newContent = getText(block);
        if (newContent !== note.content) {
          mdCache.delete(note.content); // Remove old cache
          note.content = newContent;
          save();
        }
        // Re-render with cached markdown
        block.innerHTML = parseMarkdownCached(note.content) + `
          <div class="note-actions">
            <button class="action-btn" data-action="copy">content_copy</button>
            <button class="action-btn" data-action="delete">delete</button>
          </div>`;
      };
      
      return block;
    };
    
    // Batch rendering with document fragment
    const render = (shouldScroll = false) => {
      // Remove old notes (keep spacer)
      [...container.children].forEach(child => {
        if (!child.classList.contains('spacer')) child.remove();
      });
      
      const notesToRender = searchResults || notes;
      const fragment = document.createDocumentFragment();
      
      // Batch create all notes
      notesToRender.forEach(note => {
        fragment.appendChild(createNote(note));
      });
      
      container.appendChild(fragment);
      if (shouldScroll) scroll();
    };
    
    // Helper to escape regex special characters
    const escapeRegex = s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

    // Helper to save files
    const saveFile = (filename, content) => {
      const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    };

    // Run search on a given set of notes
    const runSearch = (notes, args) => {
      if (!args) return notes;
      
      const queryTrimmed = args.trim();
      if (!queryTrimmed) return notes;
      
      // 1. Exact phrase search in quotes
      const phraseMatch = queryTrimmed.match(/"([^"]+)"/);
      if (phraseMatch) {
        const phrase = phraseMatch[1].toLowerCase();
        return notes
          .map(note => {
            const contentLC = note.content.toLowerCase();
            if (!contentLC.includes(phrase)) return null;
            const rx = new RegExp(`(${escapeRegex(phraseMatch[1])})`, 'gi');
            return { ...note, content: note.content.replace(rx, '**$1**') };
          })
          .filter(Boolean);
      }

      // 2. AND search (+ separated)
      if (queryTrimmed.includes('+')) {
        const terms = queryTrimmed
          .split('+')
          .map(t => t.trim().toLowerCase())
          .filter(t => t.length > 0);
        return notes
          .map(note => {
            const contentLC = note.content.toLowerCase();
            if (!terms.every(term => contentLC.includes(term))) return null;
            let highlighted = note.content;
            terms.forEach(term => {
              const rx = new RegExp(`(${escapeRegex(term)})`, 'gi');
              highlighted = highlighted.replace(rx, '**$1**');
            });
            return { ...note, content: highlighted };
          })
          .filter(Boolean);
      }

      // 3. OR search (comma separated, default)
      const terms = queryTrimmed
        .split(',')
        .map(t => t.trim().toLowerCase())
        .filter(t => t.length > 0);

      const results = [];
      const seenIds = new Set();
      
      terms.forEach(term => {
        const rx = new RegExp(`(${escapeRegex(term)})`, 'gi');
        notes.forEach(note => {
          if (!seenIds.has(note.id) && note.content.toLowerCase().includes(term)) {
            seenIds.add(note.id);
            results.push({ ...note, content: note.content.replace(rx, '**$1**') });
          }
        });
      });
      
      return results;
    };

    // Run export on a given set of notes
    const runExport = (notesToExport, args) => {
      if (!notesToExport.length) {
        show('[!] No notes to export');
        return;
      }
      
      const format = args || 'markdown';
      const timestamp = new Date().toISOString().split('T')[0];
      
      if (format === 'txt') {
        // Plain text export - clean format for universal compatibility
        let text = '';
        
        for (let i = 0; i < notesToExport.length; i++) {
          const note = notesToExport[i];
          // Always use original content without highlighting
          const originalNote = notes.find(n => n.id === note.id);
          const content = originalNote ? originalNote.content : note.content.replace(/\*\*(.*?)\*\*/g, '$1');
          
          if (i > 0) text += '\n\n';
          text += `${content}`;
        }
        
        saveFile(`cmdnote-${timestamp}.txt`, text);
        show(`[+] Exported ${notesToExport.length} notes as plain text`, 3000);
      } else {
        // Default markdown export - clean format for Notion, etc.
        let markdown = '';
        
        for (let i = 0; i < notesToExport.length; i++) {
          const note = notesToExport[i];
          // Always use original content without highlighting
          const originalNote = notes.find(n => n.id === note.id);
          const content = originalNote ? originalNote.content : note.content.replace(/\*\*(.*?)\*\*/g, '$1');
          
          if (i > 0) markdown += '\n';
          markdown += `---\n${content}`;
        }
        
        saveFile(`cmdnote-${timestamp}.md`, markdown);
        show(`[+] Exported ${notesToExport.length} notes as markdown`, 3000);
      }
    };

    // Command pipeline system
    const commands = {
      s: (notes, args) => runSearch(notes, args),
      search: (notes, args) => runSearch(notes, args), // Keep long form for compatibility
      exp: (notes, args) => {
        runExport(notes, args);
        return notes; // Pass current notes forward unchanged
      },
      export: (notes, args) => {
        runExport(notes, args);
        return notes; // Keep long form for compatibility
      },
      cls: (notes, args) => {
        return notes; // Will be handled specially to reset to all notes
      },
      clear: (notes, args) => {
        return notes; // Keep long form for compatibility
      }
    };

    const runPipeline = (input, allNotes) => {
      // Split by '/' and clean up
      const segments = input.split('/')
        .map(s => s.trim())
        .filter(Boolean);

      let currentNotes = allNotes;

      for (const segment of segments) {
        const [cmd, ...rest] = segment.split(' ');
        const args = rest.join(' ').trim();
        const command = cmd.toLowerCase();
        
        if (command === 'clear' || command === 'cls') {
          currentNotes = allNotes; // Reset to all notes
          continue;
        }
        
        const fn = commands[command];
        if (!fn) {
          show(`[!] Unknown command: /${cmd}`);
          return currentNotes;
        }

        // Update notes (or keep the same if command returns nothing)
        const result = fn(currentNotes, args);
        if (result !== undefined) {
          currentNotes = result;
        }
      }

      return currentNotes;
    };
    
    // Commands
    const command = input => {
      const cmd = input.trim();
      
      // Check if it's a pipeline (contains multiple commands)
      if (cmd.includes('/') && cmd.indexOf('/') > 0) {
        // Pipeline command
        const results = runPipeline(cmd, notes);
        searchResults = results === notes ? null : results;
        
        if (searchResults && !searchResults.length) {
          show('[!] No results found from pipeline');
          searchResults = null;
        }
        
        render(true);
        return;
      }
      
      // Single commands (legacy support)
      if (cmd.startsWith('/s ') || cmd.startsWith('/search ')) {
        const query = cmd.startsWith('/s ') ? cmd.slice(3).trim() : cmd.slice(8).trim();
        if (query) {
          searchResults = runSearch(notes, query);
          if (!searchResults.length) {
            show(`[!] No notes found for "${query}"`);
            searchResults = null;
          } else {
            render(true);
          }
        }
      } else if (cmd === '/cls' || cmd === '/clear') {
        searchResults = null;
        render(true);
      } else if (cmd === '/exp' || cmd === '/export') {
        const notesToExport = searchResults || notes;
        runExport(notesToExport, '');
      } else if (cmd.startsWith('/exp ') || cmd.startsWith('/export ')) {
        const format = cmd.startsWith('/exp ') ? cmd.slice(5).trim() : cmd.slice(8).trim();
        const notesToExport = searchResults || notes;
        runExport(notesToExport, format);
      } else if (cmd === '/?') {
        // Create help note
        const wasAtBottom = isAtBottom();
        
        const helpContent = `**CMDNote Help**

**Basic Usage**
Just type and press Enter to add a note.

**Commands**
/s query - Search notes (work, life OR work+urgent AND "exact phrase")
/exp [txt] - Export current view (markdown default, txt for plain text)
/cls - Clear search, show all notes
/? - Show this help

**Examples**
/s work - Find work notes
/s work, life - Find work OR life notes
/s work + idea - Find work AND idea notes
/s "exact text" - Find exact phrase
/exp - Export as markdown
/exp txt - Export as plain text

**Chaining Commands**
/s work /exp - Search work, export results
/s quotes /exp txt /cls - Search quotes, export as text, clear

**Features**
- **Edit notes**: Click any note to edit directly
- **Markdown**: Use **bold**, *italic*, \`code\`, # headings
- **Wiki links**: [[link text]] becomes clickable
- **Tags**: Use #hashtags in notes
- **Auto-save**: Everything saves automatically`;

        notes.push({
          id: Date.now(),
          content: helpContent,
          created: new Date().toISOString()
        });
        save();
        searchResults = null;
        
        render(wasAtBottom);
        
        if (!wasAtBottom) {
          show('[+] Help note added. <span class="view-text">View</span>');
        }
      } else if (cmd) {
        // Regular note creation
        const wasAtBottom = isAtBottom();
        
        notes.push({
          id: Date.now(),
          content: cmd,
          created: new Date().toISOString()
        });
        save();
        searchResults = null;
        
        render(wasAtBottom);
        
        if (!wasAtBottom) {
          show('[+] Note added. <span class="view-text">View</span>');
        }
      }
    };
    
    const exec = () => {
      command(input.value);
      input.value = '';
      autoResize(input);
    };
    
    // Event delegation for note actions - single listener handles all notes
    container.addEventListener('click', e => {
      const actionBtn = e.target.closest('[data-action]');
      if (!actionBtn) return;
      
      const noteBlock = actionBtn.closest('.note-block');
      if (!noteBlock) return;
      
      const noteId = parseInt(noteBlock.dataset.id);
      const note = notes.find(n => n.id === noteId);
      if (!note) return;
      
      const action = actionBtn.dataset.action;
      
      if (action === 'copy') {
        navigator.clipboard.writeText(getText(noteBlock)).then(() => {
          const originalText = actionBtn.textContent;
          actionBtn.textContent = 'check';
          setTimeout(() => actionBtn.textContent = originalText, 1000);
        });
      } else if (action === 'delete') {
        const index = notes.findIndex(n => n.id === noteId);
        if (index !== -1) {
          mdCache.delete(note.content); // Clean up cache
          notes.splice(index, 1);
          save();
          render(true);
        }
      }
    });
    
    // Wiki link handler
    container.addEventListener('click', e => {
      if (e.target.classList.contains('wiki-link')) {
        const query = e.target.dataset.link;
        command(`/search ${query}`);
      }
    });
    
    // Input events
    input.oninput = () => autoResize(input);
    input.onkeydown = e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        exec();
      }
    };
    
    // Button events
    $('exec-btn').onclick = exec;
    ['pointerup', 'touchend', 'mouseup'].forEach(event => {
      $('exec-btn').addEventListener(event, () => $('exec-btn').blur());
    });
    
    // Notification click
    notification.onclick = () => {
      scroll();
      notification.style.opacity = '0';
    };
    
    // Prevent iOS zoom
    document.addEventListener('gesturestart', e => e.preventDefault());
    
    // Save on page unload
    window.addEventListener('beforeunload', save);
    
    // Initialize
    notes = load();
    render(true);
  </script>
</body>
</html>
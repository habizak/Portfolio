<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CMDNote</title>
  <link href="https://fonts.googleapis.com/css2?family=PT+Mono&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20,200,0,0" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: 'PT Mono', monospace;
      font-size: 14px;
      background-color: #ffffff;
      color: #222;
      display: flex;
      flex-direction: column;
      height: 100vh;
      /* Ensure app fills viewport; avoid centering which can affect scrolling */
    }

    .app-container {
      width: 100%;
      max-width: 600px;
      height: 100vh;
      display: flex;
      flex-direction: column;
      margin: 0 auto;
      position: relative;
    }

    @media (max-width: 640px) {
      .app-container {
        max-width: 100%;
      }
    }
    
    #note-container {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0px;
    }
    
    /* Hide scrollbar */
    #note-container::-webkit-scrollbar {
      display: none;
    }
    #note-container {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    
    .note-block {
      position: relative;
      padding: 1.5rem 1.5rem 3rem 1.5rem;
      background: #ffffff;
      white-space: pre-wrap;
      line-height: 1.6;
      transition: all 300ms ease-out;
      outline: none;
    }
    
    .note-actions {
      position: absolute;
      bottom: 1rem;
      right: 1rem;
      display: flex;
      gap: 0.5rem;
      opacity: 0;
      transition: opacity 300ms ease-in-out;
    }
    
    .note-block:hover .note-actions {
      opacity: 1;
    }

    .note-block:focus-within,
    .note-block[contenteditable="true"]:focus {
      background: #F5F5F5;
    }
    
    .action-btn {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: none;
      background-color: transparent;
      color: #222;
      font-size: 18px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 300ms ease-in-out;
      font-family: 'Material Symbols Outlined';
      font-weight: normal;
      font-style: normal;
      font-variation-settings:
        'FILL' 0,
        'wght' 200,
        'GRAD' 0,
        'opsz' 20;
    }
    
    .action-btn:hover {
      background-color: #333;
      color: white;
    }
    
    .copy-btn {
      position: absolute;
      top: 0.5em;
      right: 0.75em;
      font-size: 0.85em;
      background: none;
      border: none;
      color: #aaa;
      cursor: pointer;
      display: none;
    }
    
    .note-block:hover .copy-btn {
      display: none;
    }
    
    .note-block h1, .note-block h2, .note-block h3 {
      margin: 0.5em 0;
      font-weight: bold;
    }
    .note-block h1 { font-size: 1.2em; }
    .note-block h2 { font-size: 1.1em; }
    .note-block h3 { font-size: 1em; }
    .note-block strong { font-weight: bold; }
    .note-block em { font-style: italic; }
    .note-block code {
      background: #f5f5f5;
      padding: 0.2em 0.4em;
    }
    .note-block pre {
      background: #f5f5f5;
      padding: 1em;
      overflow-x: auto;
    }
    .note-block ul, .note-block ol {
      margin: 0.5em 0;
      padding-left: 2em;
    }
    .wiki-link {
      color: #0066cc;
      text-decoration: underline;
      cursor: pointer;
    }
    .tag {
      color: #666;
      font-weight: bold;
    }
    
    #cmd-line {
      margin: 0 1rem 1rem 1rem;
      padding: 1rem;
      background: #ffffff;
      position: relative;
      min-height: 120px;
    }
    
    #cmd-input {
      width: 100%;
      min-height: 80px;
      font-size: 14px;
      font-family: inherit;
      border: none;
      outline: none;
      background: none;
      resize: none;
      line-height: 1.6;
      overflow-y: auto;
    }
    
    #cmd-input::placeholder {
      color: #C1C1C1;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <div id="note-container"></div>
    <div id="cmd-line">
      <textarea id="cmd-input" placeholder="Start typing or use /commands..." autocomplete="off" autofocus></textarea>
    </div>
  </div>
  <script>
    const cmdInput = document.getElementById('cmd-input');
    const noteContainer = document.getElementById('note-container');
    
    // Storage functions
    function saveNotes(notes) {
      try {
        window.savedNotes = notes;
      } catch (e) {
        console.warn('Could not save notes');
      }
    }
    
    function loadNotes() {
      try {
        return window.savedNotes || [];
      } catch (e) {
        return [];
      }
    }
    
    let notes = loadNotes();
    let noteIdCounter = notes.length;
    
    // Scrolling helpers
    function isUserNearBottom(container, threshold = 80) {
      const distanceFromBottom = container.scrollHeight - container.scrollTop - container.clientHeight;
      return distanceFromBottom <= threshold;
    }
    
    function scrollToBottom(container) {
      container.scrollTop = container.scrollHeight;
    }

    function scrollToTop(container) {
      container.scrollTop = 0;
    }

    // Extract only user content from a note block (exclude action buttons)
    function getNoteTextFromBlock(block) {
      const clone = block.cloneNode(true);
      const actions = clone.querySelectorAll('.note-actions');
      actions.forEach(function(el) { el.remove(); });
      return clone.innerText;
    }
    
    // Simple markdown parser
    function parseMarkdown(text) {
      return text
        // Headers
        .replace(/^### (.*$)/gm, '<h3>$1</h3>')
        .replace(/^## (.*$)/gm, '<h2>$1</h2>')
        .replace(/^# (.*$)/gm, '<h1>$1</h1>')
        // Bold and italic
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        // Code
        .replace(/`([^`]+)`/g, '<code>$1</code>')
        // Wiki links
        .replace(/\[\[(.*?)\]\]/g, '<span class="wiki-link" data-link="$1">$1</span>')
        // Tags
        .replace(/(^|\s)(#\w+)/g, '$1<span class="tag">$2</span>')
        // Lists (basic)
        .replace(/^\* (.+)$/gm, '<li>$1</li>')
        .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
        .replace(/^\d+\. (.+)$/gm, '<li>$1</li>');
    }
    
    // Add action buttons (copy and delete)
    function addActionButtons(block, note) {
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'note-actions';
      
      // Copy button
      const copyBtn = document.createElement('button');
      copyBtn.className = 'action-btn';
      copyBtn.textContent = 'content_copy';
      copyBtn.onclick = () => {
        // Get only the note content, excluding the buttons
        const contentClone = block.cloneNode(true);
        const actionsToRemove = contentClone.querySelector('.note-actions');
        if (actionsToRemove) {
          actionsToRemove.remove();
        }
        const text = contentClone.innerText;
        
        navigator.clipboard.writeText(text).then(() => {
          copyBtn.textContent = 'check';
          setTimeout(() => {
            copyBtn.textContent = 'content_copy';
          }, 1000);
        });
      };
      
      // Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'action-btn';
      deleteBtn.textContent = 'delete';
      deleteBtn.onclick = () => {
        // Remove from notes array
        const index = notes.findIndex(n => n.id === note.id);
        if (index > -1) {
          notes.splice(index, 1);
          saveNotes(notes);
        }
        // Remove from DOM
        block.remove();
      };
      
      actionsDiv.appendChild(copyBtn);
      actionsDiv.appendChild(deleteBtn);
      block.appendChild(actionsDiv);
    }
    
    function createNoteElement(note) {
      const block = document.createElement('div');
      block.className = 'note-block';
      block.setAttribute('contenteditable', 'true');
      block.dataset.id = String(note.id);
      
      const parsedContent = parseMarkdown(note.content);
      block.innerHTML = parsedContent;
      
      // Add action buttons
      addActionButtons(block, note);
      
      // Editing behavior
      let isComposing = false;
      block.addEventListener('compositionstart', function() { isComposing = true; });
      block.addEventListener('compositionend', function() { isComposing = false; });

      block.addEventListener('input', function() {
        if (isComposing) return;
        const id = note.id;
        const idx = notes.findIndex(n => n.id === id);
        if (idx > -1) {
          // Save raw text (exclude action buttons) while typing to avoid caret jumps
          notes[idx].content = getNoteTextFromBlock(block);
          saveNotes(notes);
        }
      });

      block.addEventListener('blur', function() {
        // On blur, re-parse markdown and restore action buttons
        const id = note.id;
        const idx = notes.findIndex(n => n.id === id);
        if (idx > -1) {
          const currentText = getNoteTextFromBlock(block);
          notes[idx].content = currentText;
          saveNotes(notes);
          // Re-render parsed content
          block.innerHTML = parseMarkdown(currentText);
          addActionButtons(block, notes[idx]);
        }
      });

      return block;
    }
    
    let stickToBottom = true;

    noteContainer.addEventListener('scroll', function() {
      // Update stickiness based on user position
      stickToBottom = isUserNearBottom(noteContainer);
    });

    function addNote(content) {
      const shouldStickToBottom = stickToBottom;
      const note = {
        id: ++noteIdCounter,
        content: content,
        created: new Date().toISOString()
      };
      notes.push(note);
      saveNotes(notes);
      
      const noteEl = createNoteElement(note);
      noteContainer.appendChild(noteEl);
      
      // Auto-scroll only if user was near bottom when the note was added
      if (shouldStickToBottom) {
        scrollToBottom(noteContainer);
      }
    }
    
    function showSearchResults(query) {
      const results = notes.filter(note => 
        note.content.toLowerCase().includes(query.toLowerCase())
      );
      
      let elements = [];
      
      if (results.length === 0) {
        const block = document.createElement('div');
        block.className = 'note-block';
        block.innerHTML = `No notes found for "${query}"`;
        const dummyNote = { id: 'search-' + Date.now(), content: block.innerHTML, created: new Date().toISOString() };
        addActionButtons(block, dummyNote);
        elements = [block];
      } else {
        elements = results.map(note => {
          const block = document.createElement('div');
          block.className = 'note-block';
          
          const highlightedContent = note.content.replace(
            new RegExp(`(${query})`, 'gi'), 
            '<strong>$1</strong>'
          );
          block.innerHTML = parseMarkdown(highlightedContent);
          addActionButtons(block, note);
          return block;
        });
      }
      
      showResultsBottomToTop(elements);
      notesBackup = []; // Clear backup after successful search
      isInSearchMode = false;
      scrollToBottom(noteContainer);
    }
    
    // Export function
    function exportNotes() {
      if (notes.length === 0) {
        // Show a temporary message
        const block = document.createElement('div');
        block.className = 'note-block';
        block.innerHTML = 'No notes to export';
        const dummyNote = { id: 'export-' + Date.now(), content: block.innerHTML, created: new Date().toISOString() };
        addActionButtons(block, dummyNote);
        
        block.style.opacity = '0';
        block.style.transform = 'translateY(20px)';
        noteContainer.appendChild(block);
        
        setTimeout(() => {
          block.style.opacity = '1';
          block.style.transform = 'translateY(0)';
        }, 80);
        
        // Remove after 2 seconds
        setTimeout(() => {
          block.style.opacity = '0';
          block.style.transform = 'translateY(-20px)';
          setTimeout(() => block.remove(), 300);
        }, 2000);
        
        return;
      }
      
      // Create markdown content
      let markdown = '# CMDNote Export\n\n';
      markdown += `Exported on ${new Date().toLocaleString()}\n`;
      markdown += `Total notes: ${notes.length}\n\n`;
      markdown += '---\n\n';
      
      notes.forEach((note, index) => {
        const date = new Date(note.created).toLocaleString();
        markdown += `## Note ${index + 1}\n`;
        markdown += `*Created: ${date}*\n\n`;
        markdown += note.content + '\n\n';
        markdown += '---\n\n';
      });
      
      // Create and download file
      const blob = new Blob([markdown], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `cmdnote-export-${new Date().toISOString().split('T')[0]}.md`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      // Show success message with animation
      const block = document.createElement('div');
      block.className = 'note-block';
      block.innerHTML = `Exported ${notes.length} notes to markdown file`;
      const dummyNote = { id: 'export-' + Date.now(), content: block.innerHTML, created: new Date().toISOString() };
      addActionButtons(block, dummyNote);
      
      block.style.opacity = '0';
      block.style.transform = 'translateY(20px)';
      noteContainer.appendChild(block);
      
      setTimeout(() => {
        block.style.opacity = '1';
        block.style.transform = 'translateY(0)';
      }, 80);
      
      // Remove after 3 seconds
      setTimeout(() => {
        block.style.opacity = '0';
        block.style.transform = 'translateY(-20px)';
        setTimeout(() => block.remove(), 300);
      }, 3000);
    }
    
    // Command processing
    function processCommand(input) {
      const trimmed = input.trim();
      
      if (trimmed.startsWith('/search ')) {
        const query = trimmed.replace('/search ', '').trim();
        if (query) {
          showSearchResults(query);
        }
      } else if (trimmed === '/clear') {
        clearSearchResults();
      } else if (trimmed === '/export') {
        exportNotes();
      } else if (trimmed) {
        addNote(trimmed);
      }
    }
    
    function clearSearchResults() {
      // Clear current view
      const currentBlocks = Array.from(noteContainer.children);
      
      if (currentBlocks.length > 0) {
        // Delete current results bottom-to-top
        let index = currentBlocks.length - 1;
        
        const deleteNext = () => {
          if (index < 0) {
            // After clearing, show all original notes
            showAllOriginalNotes();
            return;
          }
          
          const block = currentBlocks[index];
          block.style.opacity = '0';
          block.style.transform = 'translateY(-20px)';
          
          setTimeout(() => {
            if (block.parentNode) {
              block.remove();
            }
            index--;
            deleteNext();
          }, 80);
        };
        
        deleteNext();
      } else {
        showAllOriginalNotes();
      }
    }
    
    function showAllOriginalNotes() {
      if (notes.length === 0) return;
      
      // Create actual DOM elements instead of HTML strings
      const elements = notes.map(note => {
        const block = document.createElement('div');
        block.className = 'note-block';
        block.setAttribute('contenteditable', 'true');
        block.dataset.id = String(note.id);
        block.innerHTML = parseMarkdown(note.content);
        addActionButtons(block, note);

        // Attach editing events
        let isComposing = false;
        block.addEventListener('compositionstart', function() { isComposing = true; });
        block.addEventListener('compositionend', function() { isComposing = false; });
        block.addEventListener('input', function() {
          if (isComposing) return;
          const id = note.id;
          const idx = notes.findIndex(n => n.id === id);
          if (idx > -1) {
            notes[idx].content = getNoteTextFromBlock(block);
            saveNotes(notes);
          }
        });
        block.addEventListener('blur', function() {
          const id = note.id;
          const idx = notes.findIndex(n => n.id === id);
          if (idx > -1) {
            const currentText = getNoteTextFromBlock(block);
            notes[idx].content = currentText;
            saveNotes(notes);
            block.innerHTML = parseMarkdown(currentText);
            addActionButtons(block, notes[idx]);
          }
        });
        return block;
      });
      
      showResultsBottomToTop(elements);
      scrollToBottom(noteContainer);
    }
    
    let isAnimating = false;
    let notesBackup = []; // Store notes before deletion
    let isInSearchMode = false;
    
    // Terminal-style animation functions
    function deleteNotesBottomToTop() {
      return new Promise((resolve) => {
        const noteBlocks = Array.from(noteContainer.children);
        if (noteBlocks.length === 0) {
          resolve();
          return;
        }
        
        // Backup the current notes HTML before deleting
        notesBackup = noteBlocks.map(block => ({
          html: block.outerHTML,
          note: notes.find(n => block.innerHTML.includes(n.content.substring(0, 50)))
        }));
        
        // Delete from bottom to top
        let index = noteBlocks.length - 1;
        
        const deleteNext = () => {
          if (index < 0) {
            resolve();
            return;
          }
          
          const block = noteBlocks[index];
          block.style.opacity = '0';
          block.style.transform = 'translateY(-20px)';
          
          setTimeout(() => {
            if (block.parentNode) {
              block.remove();
            }
            index--;
            deleteNext();
          }, 80);
        };
        
        deleteNext();
      });
    }
    
    function restoreNotesBottomToTop() {
      return new Promise((resolve) => {
        if (notesBackup.length === 0) {
          resolve();
          return;
        }
        
        // Restore notes from backup
        notesBackup.forEach((backup, index) => {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = backup.html;
          const block = tempDiv.firstChild;
          
          block.style.opacity = '0';
          block.style.transform = 'translateY(20px)';
          noteContainer.appendChild(block);
          
          setTimeout(() => {
            block.style.opacity = '1';
            block.style.transform = 'translateY(0)';
            
            if (index === notesBackup.length - 1) {
              resolve();
            }
          }, index * 80);
        });
      });
    }
    
    function showResultsBottomToTop(elements) {
      // Add blocks with initial hidden state
      elements.forEach(element => {
        element.style.opacity = '0';
        element.style.transform = 'translateY(20px)';
        noteContainer.appendChild(element);
      });
      
      // Animate them in from bottom to top
      let index = 0;
      const showNext = () => {
        if (index >= elements.length) {
          return;
        }
        
        const block = elements[index];
        setTimeout(() => {
          block.style.opacity = '1';
          block.style.transform = 'translateY(0)';
          index++;
          showNext();
        }, 80);
      };
      
      showNext();
    }
    
    // Simple command highlighting
    function highlightCommand(input) {
      const value = input.value.trim();
      const commands = ['/search', '/clear', '/export'];
      
      // Check if input starts with a command
      const isCommand = commands.some(cmd => value.startsWith(cmd));
      
      if (isCommand) {
        input.classList.add('command-mode');
      } else {
        input.classList.remove('command-mode');
      }
    }
    
    // Auto-resize textarea
    function autoResize(textarea) {
      textarea.style.height = 'auto';
      textarea.style.height = Math.max(80, textarea.scrollHeight) + 'px';
      
      // Highlight commands
      highlightCommand(textarea);
    }
    
    // Event listeners
    cmdInput.addEventListener('input', function(e) {
      const value = e.target.value;
      
      // Trigger deletion animation when user types space after /search
      if (value === '/search ' && !isAnimating && !isInSearchMode) {
        isAnimating = true;
        isInSearchMode = true;
        deleteNotesBottomToTop().then(() => {
          isAnimating = false;
        });
      }
      
      // Restore notes if user abandons the search command
      if (isInSearchMode && !value.startsWith('/search ') && !isAnimating) {
        isAnimating = true;
        restoreNotesBottomToTop().then(() => {
          isAnimating = false;
          isInSearchMode = false;
        });
      }
      
      autoResize(e.target);
    });
    
    cmdInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        const input = cmdInput.value;
        processCommand(input);
        cmdInput.value = '';
        cmdInput.classList.remove('command-mode');
        autoResize(cmdInput);
      }
    });
    
    // Wiki link click handler
    noteContainer.addEventListener('click', function(e) {
      if (e.target.classList.contains('wiki-link')) {
        const linkText = e.target.dataset.link;
        showSearchResults(linkText);
      }
    });
    
    // Auto-save when page unloads
    window.addEventListener('beforeunload', function() {
      saveNotes(notes);
    });
    
    // Load existing notes on startup
    if (notes.length > 0) {
      notes.forEach(note => {
        const noteEl = createNoteElement(note);
        noteContainer.appendChild(noteEl);
      });
      // Start at bottom initially
      scrollToBottom(noteContainer);
    }

    // Removed floating scroll-to-top button
  </script>
</body>
</html>